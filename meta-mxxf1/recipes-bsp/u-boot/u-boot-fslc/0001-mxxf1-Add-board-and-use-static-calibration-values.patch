From bf96d9314d1ae1646a790f25fe1deb2cbd597d55 Mon Sep 17 00:00:00 2001
From: Hans Christian Lonstad <hcl@datarespons.no>
Date: Tue, 23 Oct 2018 14:10:23 +0200
Subject: [PATCH 1/6] mxxf1: Add board and use static calibration values

---
 arch/arm/mach-imx/mx6/Kconfig                |   10 +
 arch/arm/mach-imx/mx6/ddr.c                  |    5 +-
 board/datarespons/mxxf1/Kconfig              |   12 +
 board/datarespons/mxxf1/MAINTAINERS          |    6 +
 board/datarespons/mxxf1/Makefile             |    9 +
 board/datarespons/mxxf1/eeprom.c             |  288 +++++
 board/datarespons/mxxf1/mx6q_4x_mt41j128.cfg |  172 +++
 board/datarespons/mxxf1/mxxf1.c              | 1173 ++++++++++++++++++
 board/datarespons/mxxf1/mxxf1_gpio.h         |   30 +
 board/datarespons/mxxf1/param.c              |  317 +++++
 board/datarespons/mxxf1/param.h              |   40 +
 board/datarespons/mxxf1/spl_spi.cfg          |   10 +
 configs/mxxf1_defconfig                      |   62 +
 configs/mxxf1_spl_defconfig                  |   79 ++
 include/configs/mxxf1.h                      |  244 ++++
 15 files changed, 2456 insertions(+), 1 deletion(-)
 create mode 100644 board/datarespons/mxxf1/Kconfig
 create mode 100644 board/datarespons/mxxf1/MAINTAINERS
 create mode 100644 board/datarespons/mxxf1/Makefile
 create mode 100644 board/datarespons/mxxf1/eeprom.c
 create mode 100644 board/datarespons/mxxf1/mx6q_4x_mt41j128.cfg
 create mode 100644 board/datarespons/mxxf1/mxxf1.c
 create mode 100644 board/datarespons/mxxf1/mxxf1_gpio.h
 create mode 100644 board/datarespons/mxxf1/param.c
 create mode 100644 board/datarespons/mxxf1/param.h
 create mode 100644 board/datarespons/mxxf1/spl_spi.cfg
 create mode 100644 configs/mxxf1_defconfig
 create mode 100644 configs/mxxf1_spl_defconfig
 create mode 100644 include/configs/mxxf1.h

diff --git a/arch/arm/mach-imx/mx6/Kconfig b/arch/arm/mach-imx/mx6/Kconfig
index 521fad74b5..3519cf6821 100644
--- a/arch/arm/mach-imx/mx6/Kconfig
+++ b/arch/arm/mach-imx/mx6/Kconfig
@@ -481,6 +481,15 @@ config TARGET_ZC5601
 	select DM
 	select DM_THERMAL
 
+config TARGET_MXXF1
+	bool "mxxf1"
+	select MX6QDL
+	select BOARD_LATE_INIT
+	select SUPPORT_SPL
+	select DM
+	select DM_THERMAL
+	select BOARD_EARLY_INIT_F
+	
 endchoice
 
 config SYS_SOC
@@ -535,5 +544,6 @@ source "board/udoo/Kconfig"
 source "board/udoo/neo/Kconfig"
 source "board/wandboard/Kconfig"
 source "board/warp/Kconfig"
+source "board/datarespons/mxxf1/Kconfig"
 
 endif
diff --git a/arch/arm/mach-imx/mx6/ddr.c b/arch/arm/mach-imx/mx6/ddr.c
index 84b9236249..941f929492 100644
--- a/arch/arm/mach-imx/mx6/ddr.c
+++ b/arch/arm/mach-imx/mx6/ddr.c
@@ -60,7 +60,7 @@ static void force_delay_measurement(int bus_size)
 static void modify_dg_result(u32 *reg_st0, u32 *reg_st1, u32 *reg_ctrl)
 {
 	u32 dg_tmp_val, dg_dl_abs_offset, dg_hc_del, val_ctrl;
-
+	u32 reg0, reg1;
 	/*
 	 * DQS gating absolute offset should be modified from reflecting
 	 * (HW_DG_LOWx + HW_DG_UPx)/2 to reflecting (HW_DG_UPx - 0x80)
@@ -69,6 +69,8 @@ static void modify_dg_result(u32 *reg_st0, u32 *reg_st1, u32 *reg_ctrl)
 	val_ctrl = readl(reg_ctrl);
 	val_ctrl &= 0xf0000000;
 
+	reg0 = readl(reg_st0);
+	reg1 = readl(reg_st1);
 	dg_tmp_val = ((readl(reg_st0) & 0x07ff0000) >> 16) - 0xc0;
 	dg_dl_abs_offset = dg_tmp_val & 0x7f;
 	dg_hc_del = (dg_tmp_val & 0x780) << 1;
@@ -82,6 +84,7 @@ static void modify_dg_result(u32 *reg_st0, u32 *reg_st1, u32 *reg_ctrl)
 	val_ctrl |= (dg_dl_abs_offset + dg_hc_del) << 16;
 
 	writel(val_ctrl, reg_ctrl);
+	printf("hwst: 0x%08x, 0x%08x -> ctl: 0x%08x\n", reg0, reg1, val_ctrl);
 }
 
 static void correct_mpwldectr_result(void *reg)
diff --git a/board/datarespons/mxxf1/Kconfig b/board/datarespons/mxxf1/Kconfig
new file mode 100644
index 0000000000..49b84e7937
--- /dev/null
+++ b/board/datarespons/mxxf1/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_MXXF1
+
+config SYS_BOARD
+	default "mxxf1"
+
+config SYS_VENDOR
+	default "datarespons"
+
+config SYS_CONFIG_NAME
+	default "mxxf1"
+
+endif
diff --git a/board/datarespons/mxxf1/MAINTAINERS b/board/datarespons/mxxf1/MAINTAINERS
new file mode 100644
index 0000000000..94ea5896c8
--- /dev/null
+++ b/board/datarespons/mxxf1/MAINTAINERS
@@ -0,0 +1,6 @@
+MXXF1 BOARD
+M:	Hans Christian Lonstad <hcl@datarespons.no>
+S:	Maintained
+F:	board/datarespons/mxxf1
+F:	include/configs/mxxf1.h
+F:	configs/mxxf1_spl_defconfig
diff --git a/board/datarespons/mxxf1/Makefile b/board/datarespons/mxxf1/Makefile
new file mode 100644
index 0000000000..347618b4d2
--- /dev/null
+++ b/board/datarespons/mxxf1/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mxxf1.o eeprom.o param.o
diff --git a/board/datarespons/mxxf1/eeprom.c b/board/datarespons/mxxf1/eeprom.c
new file mode 100644
index 0000000000..e110538205
--- /dev/null
+++ b/board/datarespons/mxxf1/eeprom.c
@@ -0,0 +1,288 @@
+#ifndef CONFIG_SPL_BUILD
+#include <common.h>
+#include <i2c.h>
+#include <errno.h>
+#include <linux/ctype.h>
+#include <u-boot/crc.h>
+#include "param.h"
+#include "mxxf1_gpio.h"
+#include <malloc.h>
+#include <version.h>
+#include <asm/gpio.h>
+
+static char eeprom_content[MXXF1_EEPROM_SIZE];
+
+static struct param ee;
+static int eeprom_ok = 0;
+static int vpd_valid = 0;
+static unsigned eeprom_addr = 0;
+
+int mxxf1_eeprom_read(void)
+{
+	unsigned offset = 0;
+	unsigned end = MXXF1_EEPROM_SIZE;
+	unsigned blk_off;
+	char *buffer = eeprom_content;
+
+	i2c_set_bus_num(1);
+	//printf("%s with dev_addr= 0x%x, offs=0x%x, cnt=%d\n", __func__, dev_addr, offset, cnt);
+	/* Read data until done or would cross a page boundary.
+	 * We must write the address again when changing pages
+	 * because the next page may be in a different device.
+	 */
+	while (offset < end)
+	{
+		unsigned len;
+		unsigned maxlen;
+		uchar segment_addr = eeprom_addr;
+		blk_off = offset & 0xFF; /* block offset */
+
+		segment_addr |= (offset >> 8) & 0x7; /* block number */
+		len = end - offset;
+		maxlen = 0x100 - blk_off;
+		if ( maxlen > I2C_RXTX_LEN )
+			maxlen = I2C_RXTX_LEN;
+		if (len > maxlen)
+			len = maxlen;
+
+		if (i2c_read(segment_addr, blk_off, 1, (uint8_t*) buffer, len) != 0)
+		{
+			printf("%s: IO error\n", __func__);
+			return -EIO;
+		}
+
+		buffer += len;
+		offset += len;
+	}
+
+	return 0;
+}
+
+int mxxf1_eeprom_init(unsigned dev_addr)
+{
+	eeprom_ok = 0;
+	vpd_valid = 0;
+	eeprom_addr = dev_addr;
+	int res = mxxf1_eeprom_read();
+	if (res)
+		return res;
+	eeprom_ok = 1;
+	param_init(&ee, eeprom_content, MXXF1_EEPROM_SIZE);
+	vpd_valid = param_parse(&ee) == 0 ? 1 : 0;
+	return 0;
+}
+
+int mxxf1_eeprom_write(unsigned dev_addr, unsigned offset, uint8_t *buffer,
+		unsigned cnt)
+{
+	unsigned end = offset + cnt;
+	unsigned blk_off;
+	int rcode = 0;
+	int retries;
+	i2c_set_bus_num(1);
+	/* Write data until done or would cross a write page boundary.
+	 * We must write the address again when changing pages
+	 * because the address counter only increments within a page.
+	 */
+	printf("\n%s: Program eeprom at 0x%02x, offset %d, length %d\n", __func__,
+			dev_addr, offset, cnt);
+	gpio_set_value(GPIO_EEPROM_WP, 0);
+	while (offset < end)
+	{
+		unsigned len;
+		unsigned maxlen;
+		uchar segment_addr = dev_addr;
+
+		blk_off = offset & 0xFF; /* block offset */
+		segment_addr |= (offset >> 8) & 0x7; /* block number */
+		len = end - offset;
+		maxlen = 0x100 - blk_off;
+		if ( maxlen > 16)
+			maxlen = 16;
+		if (len > maxlen)
+			len = maxlen;
+
+		retries = 10;
+		while (retries-- && i2c_write(segment_addr, blk_off, 1, buffer, len));
+
+		if (retries <= 0)
+		{
+			printf("%s: IO error remains after timeout - giving up\n", __func__);
+			gpio_set_value(GPIO_EEPROM_WP, 1);
+			return -EIO;
+		}
+
+		buffer += len;
+		offset += len;
+		printf(".");
+		udelay(6 * 1000);
+
+	}
+	printf("\n%s: Done\n", __func__);
+	gpio_set_value(GPIO_EEPROM_WP, 1);
+	return rcode;
+}
+
+int eeprom_get_mac_addr(void)
+{
+	char *data, *key;
+	int ret = param_find(&ee, "FEC_MAC_ADDR");
+	if (ret >= 0)
+	{
+		ret = param_split(ee.param[ret], &key, &data);
+		if (ret == 0)
+		{
+			env_set("ethaddr", data);
+			free(key);
+			return 0;
+		}
+		else
+			return ret;
+
+	}
+	else
+	{
+		printf("%s: FEC_MAC_ADDR not present in eeprom\n", __func__);
+		return -1;
+	}
+
+	char *base = (char*) &eeprom_content[4];
+	char *at = base;
+	char *at_end = base + sizeof(eeprom_content);
+	int len;
+
+	while (at < at_end)
+	{
+		char *p = strstr(at, "FEC_MAC_ADDR=");
+		if (p)
+		{
+			printf("%s: found MAC info %s\n", __func__, p);
+			p += 13;
+			if ((len = strnlen(p, 20)) == 17)
+			{
+				env_set("ethaddr", p);
+			}
+			else
+				printf("%s: Illegal length %d for mac address\n", __func__,
+						len);
+			break;
+		}
+		else
+		{
+			while (at < at_end && *at != '\0')
+				at++;
+			if (at >= at_end)
+			{
+				ret = -EINVAL;
+				break;
+			}
+			else
+				at++;
+		}
+
+	}
+	if (ret)
+		printf("%s: FEC_MAC_ADDR not present in eeprom\n", __func__);
+
+	return ret;
+}
+
+static int check_and_update(const char *key, const char *value)
+{
+	int dirty = 0;
+	int psize;
+	char *param;
+	int index;
+	if (param_check_key(key) || param_check_data(value))
+	{
+		printf("%s: Illegal key/value\n", __func__);
+		return -EINVAL;
+	}
+	psize = strlen(key) + strlen(value) + 4;
+	param = malloc(psize);
+	strcpy(param, key);
+	strcat(param, "=");
+	strcat(param, value);
+	index = param_find(&ee, key);
+	if ( index < 0 )
+	{
+		param_add(&ee, param);
+		dirty = 1;
+	}
+	else
+	{
+		if (strcmp(ee.param[index], param))
+		{
+			param_update(&ee, index, param);
+			dirty = 1;
+		}
+	}
+	free(param);
+	return dirty;
+}
+
+int vpd_update_eeprom(char *touch_fw_ver)
+{
+	int retries=3;
+	int status;
+	int dirty=0;
+	dirty = check_and_update("UBOOT_VERSION", U_BOOT_VERSION);
+	if (touch_fw_ver)
+		dirty |= check_and_update("TOUCH_FW", touch_fw_ver);
+
+	if (dirty)
+	{
+		param_generate(&ee);
+		while (retries--)
+		{
+			status = mxxf1_eeprom_write(eeprom_addr, 0, ee.data, ee.size);
+			printf("%s: Validating VPD\n", __func__);
+			memset(eeprom_content, 0xff, MXXF1_EEPROM_SIZE);
+			mxxf1_eeprom_read();
+			if (memcmp(eeprom_content, ee.data, ee.size))
+			{
+				printf("%s: EEPROM did not validate!\n", __func__);
+				eeprom_ok = 0;
+				vpd_valid = 0;
+			}
+			else
+			{
+				printf("%s: EEPROM validated\n", __func__);
+				eeprom_ok = 1;
+				vpd_valid = 1;
+				return 1;
+			}
+		}
+		printf("%s: Failed to write EEPROM\n", __func__);
+	}
+	return 0;
+}
+
+static int do_vpd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int n;
+	if (argc > 1 && strcmp(argv[1], "erase") == 0)
+	{
+		memset(eeprom_content, 0xff, MXXF1_EEPROM_SIZE);
+		mxxf1_eeprom_write(eeprom_addr, 0, (uint8_t*)eeprom_content, MXXF1_EEPROM_SIZE);
+
+	}
+	if (!vpd_valid)
+	{
+		printf("BAD EEPROM CRC\n");
+		return 0;
+	}
+	for (n = 0; n < ee.count; n++)
+	{
+		printf("%s\n", ee.param[n]);
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+		vpd, 2, 1, do_vpd,
+		"show VPD data",
+		"  Print Vital Product Data for MXXF1\n"
+);
+
+#endif
diff --git a/board/datarespons/mxxf1/mx6q_4x_mt41j128.cfg b/board/datarespons/mxxf1/mx6q_4x_mt41j128.cfg
new file mode 100644
index 0000000000..a53f3a4537
--- /dev/null
+++ b/board/datarespons/mxxf1/mx6q_4x_mt41j128.cfg
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4 0x020e05a8 0x00000030
+DATA 4 0x020e05b0 0x00000030
+DATA 4 0x020e0524 0x00000030
+DATA 4 0x020e051c 0x00000030
+
+DATA 4 0x020e0518 0x00000030
+DATA 4 0x020e050c 0x00000030
+DATA 4 0x020e05b8 0x00000030
+DATA 4 0x020e05c0 0x00000030
+
+DATA 4 0x020e05ac 0x00020030
+DATA 4 0x020e05b4 0x00020030
+DATA 4 0x020e0528 0x00020030
+DATA 4 0x020e0520 0x00020030
+
+DATA 4 0x020e0514 0x00020030
+DATA 4 0x020e0510 0x00020030
+DATA 4 0x020e05bc 0x00020030
+DATA 4 0x020e05c4 0x00020030
+
+DATA 4 0x020e056c 0x00020030
+DATA 4 0x020e0578 0x00020030
+DATA 4 0x020e0588 0x00020030
+DATA 4 0x020e0594 0x00020030
+
+DATA 4 0x020e057c 0x00020030
+DATA 4 0x020e0590 0x00003000
+DATA 4 0x020e0598 0x00003000
+DATA 4 0x020e058c 0x00000000
+
+DATA 4 0x020e059c 0x00003030
+DATA 4 0x020e05a0 0x00003030
+DATA 4 0x020e0784 0x00000030
+DATA 4 0x020e0788 0x00000030
+
+DATA 4 0x020e0794 0x00000030
+DATA 4 0x020e079c 0x00000030
+DATA 4 0x020e07a0 0x00000030
+DATA 4 0x020e07a4 0x00000030
+
+DATA 4 0x020e07a8 0x00000030
+DATA 4 0x020e0748 0x00000030
+DATA 4 0x020e074c 0x00000030
+DATA 4 0x020e0750 0x00020000
+
+DATA 4 0x020e0758 0x00000000
+DATA 4 0x020e0774 0x00020000
+DATA 4 0x020e078c 0x00000030
+DATA 4 0x020e0798 0x000C0000
+
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+DATA 4 0x021b481c 0x33333333
+DATA 4 0x021b4820 0x33333333
+DATA 4 0x021b4824 0x33333333
+DATA 4 0x021b4828 0x33333333
+
+DATA 4 0x021b0018 0x00081740
+
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b000c 0x555A7974
+DATA 4 0x021b0010 0xDB538F64
+DATA 4 0x021b0014 0x01FF00DB
+DATA 4 0x021b002c 0x000026D2
+
+DATA 4 0x021b0030 0x005A1023
+DATA 4 0x021b0008 0x09444040
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0040 0x00000027
+DATA 4 0x021b0000 0x831A0000
+
+DATA 4 0x021b001c 0x04088032
+DATA 4 0x021b001c 0x0408803A
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x0000803B
+DATA 4 0x021b001c 0x00428031
+DATA 4 0x021b001c 0x00428039
+DATA 4 0x021b001c 0x19308030
+DATA 4 0x021b001c 0x19308038
+
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b001c 0x04008048
+DATA 4 0x021b0800 0xA1380003
+DATA 4 0x021b4800 0xA1380003
+DATA 4 0x021b0020 0x00005800
+DATA 4 0x021b0818 0x00022227
+DATA 4 0x021b4818 0x00022227
+
+DATA 4 0x021b083c 0x434B0350
+DATA 4 0x021b0840 0x034C0359
+DATA 4 0x021b483c 0x434B0350
+DATA 4 0x021b4840 0x03650348
+DATA 4 0x021b0848 0x4436383B
+DATA 4 0x021b4848 0x39393341
+DATA 4 0x021b0850 0x35373933
+DATA 4 0x021b4850 0x48254A36
+
+DATA 4 0x021b080c 0x001F001F
+DATA 4 0x021b0810 0x001F001F
+
+DATA 4 0x021b480c 0x00440044
+DATA 4 0x021b4810 0x00440044
+
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b48b8 0x00000800
+
+DATA 4 0x021b001c 0x00000000
+DATA 4 0x021b0404 0x00011006
+
+/* set the default clock gate to save power */
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0x00FFF300
+DATA 4 0x020c407c 0x0F0000C3
+DATA 4 0x020c4080 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4 0x020e0010 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  = 1	   --> CKO1 enabled
+ * cko1_div = 111  --> divide by 8
+ * cko1_sel = 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+ */
+DATA 4 0x020c4060 0x000000fb
diff --git a/board/datarespons/mxxf1/mxxf1.c b/board/datarespons/mxxf1/mxxf1.c
new file mode 100644
index 0000000000..606b707288
--- /dev/null
+++ b/board/datarespons/mxxf1/mxxf1.c
@@ -0,0 +1,1173 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/mach-imx/sata.h>
+#include <errno.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/mach-imx/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/mach-imx/sys_proto.h>
+#include <i2c.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+//#include "../common/pfuze.h"
+#include <usb.h>
+#include <pwm.h>
+#include <version.h>
+#include <watchdog.h>
+
+
+#define CMD_CRC32
+
+#define USE_PWM_FOR_BL
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+		      PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SLOWOUT_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_LOW   |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+
+#define OUT_LOW_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW   |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+
+#define REGINP_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_LOW   |		\
+	PAD_CTL_DSE_DISABLE  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL_UP  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED   |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL_DN  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED   |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+
+#define I2C_PMIC	1
+
+#define I2C_PAD MUX_PAD_CTRL(I2C_PAD_CTRL)
+
+#include "mxxf1_gpio.h"
+
+typedef enum  { SW1AB, SW1C, SW3AB } pf100_regs;
+typedef enum {VER_PANEL, VER_DIN, VER_UNKNOWN} PanelVersion;
+#ifndef CONFIG_SPL_BUILD
+static PanelVersion board_version = VER_UNKNOWN;
+#endif
+int vpd_update_eeprom(char *touch_fw_ver);
+
+int dram_init(void)
+{
+	gd->ram_size = imx_ddr_size();
+	return 0;
+}
+
+iomux_v3_cfg_t const uart1_pads[] = {
+	IOMUX_PADS(PAD_CSI0_DAT10__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT11__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+};
+
+iomux_v3_cfg_t const extra_nandf_pads[] = {
+	IOMUX_PADS(PAD_NANDF_CS0__GPIO6_IO11		| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* SPI_NOR_WP	*/
+	IOMUX_PADS(PAD_NANDF_CS1__GPIO6_IO14		| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* LAN2_EEWP	*/
+	IOMUX_PADS(PAD_NANDF_CS2__GPIO6_IO15		| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* LCD_EN		*/
+	IOMUX_PADS(PAD_NANDF_CS3__GPIO6_IO16		| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* CAP_TCH_RST	*/
+
+	IOMUX_PADS(PAD_NANDF_ALE__GPIO6_IO08		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* CAP_TCH_INT	*/
+	IOMUX_PADS(PAD_NANDF_CLE__GPIO6_IO07		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* USBP3_OC		*/
+	IOMUX_PADS(PAD_NANDF_WP_B__GPIO6_IO09		| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* USBP3_EN		*/
+	IOMUX_PADS(PAD_NANDF_RB0__GPIO6_IO10		| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* AUX_5V_EN	*/
+
+	IOMUX_PADS(PAD_NANDF_D2__GPIO2_IO02		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* USBP1_OC		*/
+	IOMUX_PADS(PAD_NANDF_D3__GPIO2_IO03		| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* USBP1_EN		*/
+
+	IOMUX_PADS(PAD_NANDF_D4__GPIO2_IO04		| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* WDOG_PWR_EN	*/
+	IOMUX_PADS(PAD_NANDF_D5__GPIO2_IO05		| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* EMMC_RST#	*/
+	IOMUX_PADS(PAD_NANDF_D6__GPIO2_IO06		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* USBP2_OC		*/
+	IOMUX_PADS(PAD_NANDF_D7__GPIO2_IO07		| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* USBP2_EN		*/
+};
+
+iomux_v3_cfg_t const extra_nvcc_gpio_pads[] = {
+	IOMUX_PADS(PAD_KEY_COL0__GPIO4_IO06		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* DIMM-	*/
+	IOMUX_PADS(PAD_KEY_ROW0__GPIO4_IO07		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* DIMM+	*/
+	IOMUX_PADS(PAD_KEY_COL1__GPIO4_IO08		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* TEMP_OS	*/
+
+	IOMUX_PADS(PAD_KEY_COL2__GPIO4_IO10		| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* CODEC_PWR_EN	*/
+	IOMUX_PADS(PAD_KEY_ROW2__GPIO4_IO11		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* HDMI_CEC_IN	*/
+
+	IOMUX_PADS(PAD_KEY_COL4__FLEXCAN2_TX		| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* CAN2_TX	*/
+	IOMUX_PADS(PAD_KEY_ROW4__FLEXCAN2_RX		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* CAN2_RX	*/
+
+	IOMUX_PADS(PAD_GPIO_0__CCM_CLKO1			| MUX_PAD_CTRL(PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_HIGH)),	/* AUD_MCLK	*/
+	IOMUX_PADS(PAD_GPIO_1__WDOG2_B				| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* WDOG_B		*/
+	IOMUX_PADS(PAD_GPIO_2__GPIO1_IO02			| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* BLON_3V_H	*/
+
+	IOMUX_PADS(PAD_GPIO_4__GPIO1_IO04			| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* TCH_PWRON	*/
+	IOMUX_PADS(PAD_GPIO_5__GPIO1_IO05			| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* EEPROM_WP	*/
+	IOMUX_PADS(PAD_GPIO_7__FLEXCAN1_TX			| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* CAN1_TX	*/
+
+	IOMUX_PADS(PAD_GPIO_8__FLEXCAN1_RX			| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* CAN1_RX		*/
+#ifdef USE_PWM_FOR_BL
+	IOMUX_PADS(PAD_GPIO_9__PWM1_OUT			| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/*  BL_PWM		*/
+#else
+	IOMUX_PADS(PAD_GPIO_9__GPIO1_IO09			| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),
+#endif
+	IOMUX_PADS(PAD_GPIO_17__GPIO7_IO12			| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* PCIE_RST	*/
+	IOMUX_PADS(PAD_GPIO_18__GPIO7_IO13			| MUX_PAD_CTRL(PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_100K_DOWN)),	/* PMIC_INT_B	*/
+
+};
+
+iomux_v3_cfg_t const extra_pads[] = {
+	IOMUX_PADS(PAD_ENET_RX_ER__GPIO1_IO24		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* USB_OTG_ID	*/
+	IOMUX_PADS(PAD_ENET_RXD0__GPIO1_IO27		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* UOK_B		*/
+	IOMUX_PADS(PAD_ENET_TXD1__GPIO1_IO29		| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* USB_H1_PWR_EN	*/
+	IOMUX_PADS(PAD_SD1_CMD__GPIO1_IO18			| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* FAN_EN		*/
+	IOMUX_PADS(PAD_SD1_DAT1__PWM3_OUT			| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* BUZ_INT_EN	*/
+	IOMUX_PADS(PAD_SD1_DAT2__GPIO1_IO19		| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* BUZ_EXT_EN	*/
+
+	IOMUX_PADS(PAD_CSI0_DATA_EN__GPIO5_IO20	| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* PCIE_WAKE_B	*/
+
+	IOMUX_PADS(PAD_EIM_D21__GPIO3_IO21			| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* USB_OTG_OC		*/
+	IOMUX_PADS(PAD_EIM_D22__GPIO3_IO22			| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* USB_ORG_PWR_EN	*/
+	IOMUX_PADS(PAD_EIM_D29__GPIO3_IO29			| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* PWR_BTN_SNS		*/
+	IOMUX_PADS(PAD_EIM_D30__GPIO3_IO30			| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* USB_H1_OC		*/
+	IOMUX_PADS(PAD_EIM_D31__GPIO3_IO31			| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* USB_P0_OC		*/
+	IOMUX_PADS(PAD_EIM_D28__GPIO3_IO28			| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* USBP0_EN			*/
+
+	IOMUX_PADS(PAD_EIM_D23__GPIO3_IO23			| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* LAN2_DEV_OFF#	*/
+	IOMUX_PADS(PAD_EIM_D24__GPIO3_IO24			| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* LAN2_SMB_ALRT#	*/
+	IOMUX_PADS(PAD_GPIO_16__GPIO7_IO11			| MUX_PAD_CTRL(OUT_LOW_PAD_CTRL)),	/* LVDS_ROTATE		*/
+
+};
+
+iomux_v3_cfg_t const audio_pads[] = {
+	IOMUX_PADS(PAD_CSI0_DAT4__AUD3_TXC		| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* AUD3_TXC		*/
+	IOMUX_PADS(PAD_CSI0_DAT5__AUD3_TXD		| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* AUD3_TXD		*/
+	IOMUX_PADS(PAD_CSI0_DAT6__AUD3_TXFS	| MUX_PAD_CTRL(SLOWOUT_PAD_CTRL)),	/* AUD3_TXFS	*/
+	IOMUX_PADS(PAD_CSI0_DAT7__AUD3_RXD		| MUX_PAD_CTRL(REGINP_PAD_CTRL)),	/* AUD3_RXD		*/
+};
+
+iomux_v3_cfg_t const enet_pads[] = {
+	IOMUX_PADS(PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL_UP)),
+	IOMUX_PADS(PAD_ENET_MDC__ENET_MDC			| MUX_PAD_CTRL(ENET_PAD_CTRL_UP)),
+	IOMUX_PADS(PAD_RGMII_TXC__RGMII_TXC		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_TD0__RGMII_TD0		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_TD1__RGMII_TD1		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_TD2__RGMII_TD2		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_TD3__RGMII_TD3		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_RXC__RGMII_RXC		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_RD0__RGMII_RD0		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_RD1__RGMII_RD1		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_RD2__RGMII_RD2		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_RD3__RGMII_RD3		| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	IOMUX_PADS(PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL_DN)),
+	/* AR8031 PHY Reset */
+	IOMUX_PADS(PAD_ENET_CRS_DV__GPIO1_IO25		| MUX_PAD_CTRL(ENET_PAD_CTRL_UP)),
+	IOMUX_PADS(PAD_ENET_TX_EN__GPIO1_IO28		| MUX_PAD_CTRL(ENET_PAD_CTRL_UP)), 	/* ENET_WOL_INT (low)	*/
+	IOMUX_PADS(PAD_ENET_RXD1__GPIO1_IO26		| MUX_PAD_CTRL(ENET_PAD_CTRL_UP)), 	/* RGMII_INT (low)	*/
+};
+
+
+iomux_v3_cfg_t const usdhc3_pads[] = {
+	IOMUX_PADS(PAD_SD3_CLK__SD3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_CMD__SD3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT4__SD3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_D0__GPIO2_IO00    | MUX_PAD_CTRL(REGINP_PAD_CTRL)), 		/* CD 				*/
+	IOMUX_PADS(PAD_NANDF_D1__GPIO2_IO01    | MUX_PAD_CTRL(REGINP_PAD_CTRL)),		/* WP 				*/
+	IOMUX_PADS(PAD_SD3_RST__GPIO7_IO08	  | MUX_PAD_CTRL(REGINP_PAD_CTRL)),		/* HEADPHONE_DET	*/
+};
+
+iomux_v3_cfg_t const usdhc4_pads[] = {
+	IOMUX_PADS(PAD_SD4_CLK__SD4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_CMD__SD4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT4__SD4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT5__SD4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT6__SD4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_D5__GPIO2_IO05    | MUX_PAD_CTRL(USDHC_PAD_CTRL)),	/* eMMC reset */
+};
+
+struct i2c_pads_info i2c_pad_info0 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_CSI0_DAT9__I2C1_SCL | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_CSI0_DAT9__GPIO5_IO27 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(5, 27)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_CSI0_DAT8__I2C1_SDA | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_CSI0_DAT8__GPIO5_IO26 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(5, 26)
+	}
+};
+
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_KEY_COL3__I2C2_SCL | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_COL3__GPIO4_IO12 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_KEY_ROW3__I2C2_SDA | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_ROW3__GPIO4_IO13 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_GPIO_3__I2C3_SCL | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_3__GPIO1_IO03 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 3)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_GPIO_6__I2C3_SDA | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_6__GPIO1_IO06 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 6)
+	}
+};
+
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	/* SS1 */
+	IOMUX_PADS(PAD_EIM_D19__GPIO3_IO19  | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+};
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 0)
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = 1; /* eMMC/uSDHC4 is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+#ifndef CONFIG_SPL_BUILD
+	int ret;
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD2
+	 * mmc1                    SD3
+	 * mmc2                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			SETUP_IOMUX_PADS(usdhc3_pads);
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 1:
+			SETUP_IOMUX_PADS(usdhc4_pads);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+			       "(%d) then supported by the board (%d)\n",
+			       i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+#else
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	unsigned reg = readl(&psrc->sbmr1) >> 11;
+	/*
+	 * Upon reading BOOT_CFG register the following map is done:
+	 * Bit 11 and 12 of BOOT_CFG register can determine the current
+	 * mmc port
+	 * 0x1                  SD1
+	 * 0x2                  SD2
+	 * 0x3                  SD4
+	 */
+
+	switch (reg & 0x3) {
+	case 0x2:
+		SETUP_IOMUX_PADS(usdhc3_pads);
+		usdhc_cfg[0].esdhc_base = USDHC3_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+		gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+		break;
+	case 0x3:
+		SETUP_IOMUX_PADS(usdhc4_pads);
+		usdhc_cfg[0].esdhc_base = USDHC4_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+		gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+		break;
+	}
+
+	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+#endif
+}
+#endif
+
+int overwrite_console(void)
+{
+	return 0;
+}
+
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= 0xffe3;
+	val |= 0x18;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_VIDEO_IPUV3)
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+static void enable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)
+				IOMUXC_BASE_ADDR;
+	u32 reg = readl(&iomux->gpr[2]);
+	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT |
+	       IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT;
+	writel(reg, &iomux->gpr[2]);
+}
+
+
+struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= enable_lvds,
+	.mode	= {
+			.name           = "MXXF1-XGA",
+			.refresh        = 60,
+			.xres           = 1024,
+			.yres           = 768,
+			.pixclock       = 15385,
+			.left_margin    = 220,
+			.right_margin   = 40,
+			.upper_margin   = 21,
+			.lower_margin   = 7,
+			.hsync_len      = 60,
+			.vsync_len      = 10,
+			.sync           = FB_SYNC_EXT,
+			.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= detect_hdmi,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+			.name           = "HDMI",
+			.refresh        = 60,
+			.xres           = 1280,
+			.yres           = 720,
+			.pixclock       = 15686,
+			.left_margin    = 48,
+			.right_margin   = 32,
+			.upper_margin   = 3,
+			.lower_margin   = 5,
+			.hsync_len      = 80,
+			.vsync_len      = 13,
+			.sync           = FB_SYNC_EXT,
+			.vmode          = FB_VMODE_NONINTERLACED
+} },  };
+size_t display_count = ARRAY_SIZE(displays);
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT
+	     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT
+	     | IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED
+	     | IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK
+			| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       << IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+}
+#else
+	void setup_display(void) {}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+
+#ifndef CONFIG_SPL_BUILD
+#define MAX_I2C_DATA_LEN 10
+static char egalax_fw[32];
+static int egalax_firmware_version(void)
+{
+	int to=100000;
+	static const uint8_t cmd[MAX_I2C_DATA_LEN] = { 0x03, 0x03, 0xa, 0x01, 'D', 0, 0, 0, 0, 0 };
+	uint8_t rcv_buf[MAX_I2C_DATA_LEN+1];
+
+	int ret;
+	gpio_set_value(GPIO_CAP_TOUCH_RST, 0);
+	udelay(500);
+	gpio_set_value(GPIO_CAP_TOUCH_RST, 1);
+	udelay(500);
+	i2c_set_bus_num(2);
+	i2c_set_bus_speed(CONFIG_SYS_I2C_SPEED);
+
+	ret = i2c_probe(0x04);
+	if (ret)
+	{
+		printf("%s: NO touch controller\n", __func__);
+		return -ENODEV;
+	}
+	if (i2c_write(0x04, 0, 0, (uint8_t*)cmd, MAX_I2C_DATA_LEN))
+	{
+		printf("%s: Error requesting FW version\n", __func__);
+		return -EIO;
+	}
+	else
+	{
+		while (gpio_get_value(GPIO_TOUCH_IRQ) && to > 0)
+		{
+			udelay(1000);
+			to--;
+		}
+		if (to <= 0)
+		{
+			printf("%s: timeout waiting for touch irq\n", __func__);
+			return -EIO;
+		}
+		ret = i2c_read(0x04, 0, 0, rcv_buf, MAX_I2C_DATA_LEN);
+		if (ret)
+		{
+			printf("%s: Error receiving FW version\n", __func__);
+			return -EIO;
+		}
+		if (rcv_buf[0] == 0x03 && rcv_buf[4] == 'D')
+		{
+			rcv_buf[MAX_I2C_DATA_LEN] = '\0';
+			strcpy(egalax_fw, (char *)&rcv_buf[5]);
+			printf("%s: FW version [%s]\n", __func__, egalax_fw);
+		}
+		else
+		{
+			printf("%s: Got touch message %x.%x.%x\n", __func__, rcv_buf[0], rcv_buf[1], rcv_buf[2]);
+			return -EINVAL;
+		}
+	}
+
+	gpio_set_value(GPIO_CAP_TOUCH_RST, 0);
+	udelay(500);
+	gpio_set_value(GPIO_CAP_TOUCH_RST, 1);
+	return 0;
+}
+
+static void setup_iomux_enet(void)
+{
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(1, 25) , 0);
+	gpio_direction_output(GPIO_CAP_TOUCH_RST, 0);
+
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 25), 1);
+	gpio_set_value(GPIO_CAP_TOUCH_RST, 1);
+}
+
+
+int mxxf1_eeprom_init (unsigned dev_addr);
+int eeprom_get_mac_addr(void);
+int eeprom_addr;
+
+static PanelVersion check_version(void)
+{
+	PanelVersion ret=VER_UNKNOWN;
+	eeprom_addr = MXXF1_EEPROM_ADDR2;
+	i2c_set_bus_num(1);
+	i2c_set_bus_speed(CONFIG_SYS_I2C_SPEED);
+	ret = i2c_probe(eeprom_addr);
+
+	if (ret == 0)
+	{
+		printf("%s: I2C EEPROM at 0x%x - DIN RAIL version\n", __func__, eeprom_addr);
+		ret = VER_DIN;
+	}
+	else
+	{
+		eeprom_addr = MXXF1_EEPROM_ADDR;
+		ret = i2c_probe(eeprom_addr);
+		if (ret == 0)
+		{
+			printf("%s: I2C EEPROM at 0x%x - PANEL version\n", __func__, eeprom_addr);
+			ret = VER_PANEL;
+		}
+	}
+
+	return ret;
+}
+
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+	return cpu_eth_init(bis);
+}
+#endif
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+#ifndef CONFIG_SPL_BUILD
+static void setup_usb(void)
+{
+	/*
+	 * set daisy chain for otg_pin_id on 6q.
+	 * for 6dl, this bit is reserved
+	 */
+	imx_iomux_set_gpr_register(1, 13, 1, 0);
+}
+#endif
+
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		if (on) {
+			gpio_direction_output(GPIO_USB_H1_EN, 1);
+			mdelay(10);
+			gpio_direction_output(GPIO_USBP0_EN, 1);
+			mdelay(1);
+			gpio_direction_output(GPIO_USBP1_EN, 1);
+			mdelay(1);
+			gpio_direction_output(GPIO_USBP2_EN, 1);
+			mdelay(1);
+			gpio_direction_output(GPIO_USBP3_EN, 1);
+			mdelay(10);
+		}
+		else {
+			gpio_direction_output(GPIO_USB_H1_EN, 0);
+			gpio_direction_output(GPIO_USBP0_EN, 0);
+			gpio_direction_output(GPIO_USBP1_EN, 0);
+			gpio_direction_output(GPIO_USBP2_EN, 0);
+			gpio_direction_output(GPIO_USBP3_EN, 0);
+		}
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+static const u32 buzzer_period = 1000000000/2300;
+
+int board_early_init_f(void)
+{
+
+	SETUP_IOMUX_PADS(enet_pads);
+	SETUP_IOMUX_PADS(extra_pads);
+	SETUP_IOMUX_PADS(extra_nandf_pads);
+	SETUP_IOMUX_PADS(extra_nvcc_gpio_pads);
+	SETUP_IOMUX_PADS(uart1_pads);
+	SETUP_IOMUX_PADS(ecspi1_pads);
+	/* Bring up basic power for serial debug etc	*/
+
+	gpio_direction_output(GPIO_PCIE_RST_N, 1);
+	gpio_direction_output(GPIO_EEPROM_WP, 1);
+	gpio_direction_output(GPIO_LAN2_EE_WP, 1);
+	gpio_direction_output(GPIO_SPI_NOR_WP, 1);
+	gpio_direction_output(GPIO_CAP_TOUCH_PWR, 1);
+	gpio_direction_output(GPIO_LCD_EN, 0);
+	gpio_direction_output(GPIO_BL_EN, 0);
+	/* gpio_direction_output(GPIO_BL_PWM, 0); */
+	gpio_direction_output(GPIO_FAN_EN, 0);
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info0);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+	gpio_direction_output(GPIO_BUZ_EXT_EN, 0);
+	gpio_direction_output(GPIO_LVDS_ROTATE, 0);
+	gpio_direction_output(GPIO_AUX_5V, 1);
+	gpio_direction_input(GPIO_DIMM_DN);
+	gpio_direction_input(GPIO_DIMM_UP);
+	gpio_direction_input(GPIO_TOUCH_IRQ);
+
+#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+#ifndef CONFIG_SPL_BUILD
+	if (pwm_config(2, buzzer_period/2, buzzer_period))
+		printf("%s: pwm_config for buzzer ERROR\n", __func__);
+	pwm_disable(2);
+#endif
+	return 0;
+}
+
+#ifndef CONFIG_SPL_BUILD
+int board_init(void)
+{
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+
+	if (get_imx_reset_cause() == 0x00010) {
+		clrbits_le32(&iomuxc_regs->gpr[12], IOMUXC_GPR12_APPS_LTSSM_ENABLE);
+	}
+
+	printf("Init\n");
+	board_version = check_version();
+
+	setup_display();
+
+#ifdef USE_PWM_FOR_BL
+	if (pwm_config(0, 2500, 5000))
+		printf("%s: pwm_config for backlight ERROR\n", __func__);
+
+	pwm_enable(0);
+#else
+	gpio_direction_output(GPIO_BL_PWM, 1);
+#endif
+	gpio_set_value(GPIO_LCD_EN, 1);
+	gpio_set_value(GPIO_BL_EN, 1);
+	setup_usb();
+	setup_sata();
+
+	if (mxxf1_eeprom_init(eeprom_addr))
+	{
+		printf("%s: Failed to init VPD eeprom\n", __func__);
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 1) ? (IMX_GPIO_NR(3, 19)) : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd3",	 MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	/* 8 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+#ifndef CONFIG_SPL_BUILD
+static char * const usbcmd[] = {"usb", "start"};
+static char * const reset_env_cmd[] = {"env", "default", "-a"};
+static char * const save_env_cmd[] = {"env", "save"};
+
+
+int board_late_init(void)
+{
+	int rep;
+	ulong ticks;
+	char *version_from_env;
+	char *fdt_defined;
+
+
+	version_from_env = env_get("UBOOT_VERSION");
+	if (version_from_env == 0 || strncmp(U_BOOT_VERSION, version_from_env, 128))
+	{
+		if (board_version == VER_PANEL)
+		{
+			env_set("stdout", "vga");
+			env_set("stderr", "vga");
+		}
+		printf("U-Boot version [%s] differs from env [%s] - update\n", U_BOOT_VERSION, version_from_env);
+		cmd_process(0, 3, reset_env_cmd, &rep, &ticks);
+		env_set("UBOOT_VERSION", U_BOOT_VERSION);
+		cmd_process(0, 2, save_env_cmd, &rep, &ticks);
+	}
+
+	fdt_defined = env_get("fdt_file");
+	switch (board_version)
+	{
+	case VER_DIN:
+		if (NULL == fdt_defined)
+			env_set("fdt_file", "/boot/mxxf1-hdmi.dtb");
+		break;
+
+	case VER_PANEL:
+		env_set("stdout", "vga");
+		env_set("stderr", "vga");
+		if (NULL == fdt_defined)
+			env_set("fdt_file", "/boot/mxxf1.dtb");
+		break;
+
+	default:
+		break;
+	}
+	printf("MXXF1 U-BOOT version [%s]\n", U_BOOT_VERSION);
+	if (egalax_firmware_version() == 0)
+		vpd_update_eeprom(egalax_fw);
+	else
+		vpd_update_eeprom(0);
+
+	cmd_process(0, 2, usbcmd, &rep, &ticks);
+	eeprom_get_mac_addr();
+
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+	return 0;
+}
+#endif
+
+int checkboard(void)
+{
+	puts("Board: MXXF1\n");
+	return 0;
+}
+
+#ifdef CONFIG_SPL_BUILD
+#include <spl.h>
+#include <asm/arch/mx6-ddr.h>
+int mx6_ddr_init(ulong addr);
+
+const struct mx6dq_iomux_ddr_regs mx6_ddr_ioregs = {
+	.dram_sdclk_0 =  0x00020030,
+	.dram_sdclk_1 =  0x00020030,
+	.dram_cas =  0x00020030,
+	.dram_ras =  0x00020030,
+	.dram_reset =  0x00020030,
+	.dram_sdcke0 =  0x00003000,
+	.dram_sdcke1 =  0x00003000,
+	.dram_sdba2 =  0x00000000,
+	.dram_sdodt0 =  0x00003030,
+	.dram_sdodt1 =  0x00003030,
+	.dram_sdqs0 =  0x00000030,
+	.dram_sdqs1 =  0x00000030,
+	.dram_sdqs2 =  0x00000030,
+	.dram_sdqs3 =  0x00000030,
+	.dram_sdqs4 =  0x00000030,
+	.dram_sdqs5 =  0x00000030,
+	.dram_sdqs6 =  0x00000030,
+	.dram_sdqs7 =  0x00000030,
+	.dram_dqm0 =  0x00020030,
+	.dram_dqm1 =  0x00020030,
+	.dram_dqm2 =  0x00020030,
+	.dram_dqm3 =  0x00020030,
+	.dram_dqm4 =  0x00020030,
+	.dram_dqm5 =  0x00020030,
+	.dram_dqm6 =  0x00020030,
+	.dram_dqm7 =  0x00020030,
+};
+
+const struct mx6dq_iomux_grp_regs mx6_grp_ioregs = {
+	.grp_ddr_type =  0x000C0000,
+	.grp_ddrmode_ctl =  0x00020000,
+	.grp_ddrpke =  0x00000000,
+	.grp_addds =  0x00000030,
+	.grp_ctlds =  0x00000030,
+	.grp_ddrmode =  0x00020000,
+	.grp_b0ds =  0x00000030,
+	.grp_b1ds =  0x00000030,
+	.grp_b2ds =  0x00000030,
+	.grp_b3ds =  0x00000030,
+	.grp_b4ds =  0x00000030,
+	.grp_b5ds =  0x00000030,
+	.grp_b6ds =  0x00000030,
+	.grp_b7ds =  0x00000030,
+};
+
+const struct mx6_mmdc_calibration mx6_mmcd_calib = {
+	.p0_mpwrdlctl =  0x40404040,
+	.p1_mpwrdlctl =  0x40404040,
+};
+
+const struct mx6_mmdc_calibration mx6_mmcd_calib_static = {
+	/* write leveling calibration */
+	.p0_mpwldectrl0 = 0x00160018,
+	.p0_mpwldectrl1 = 0x0025001A,
+	.p1_mpwldectrl0 = 0x0017002B,
+	.p1_mpwldectrl1 = 0x0017002F,
+	/* Read DQS Gating calibration */
+	.p0_mpdgctrl0 = 0x032C0338,
+	.p0_mpdgctrl1 = 0x03280324,
+	.p1_mpdgctrl0 = 0x03300340,
+	.p1_mpdgctrl1 = 0x03280268,
+	/* Read Calibration: DQS delay relative to DQ read access */
+	.p0_mprddlctl = 0x3C343234,
+	.p1_mprddlctl = 0x3636303E,
+	/* Write Calibration: DQ/DM delay relative to DQS write access */
+	.p0_mpwrdlctl = 0x363A3C3C,
+	.p1_mpwrdlctl = 0x4630483C,
+};
+
+
+static struct mx6_mmdc_calibration calib = {0};
+
+static struct mx6_ddr3_cfg mem_ddr = {
+	.mem_speed = 1600,
+	.density = 2,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 14,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+	.SRT = 1,
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0x00C03F3F, &ccm->CCGR0);
+	writel(0x0030FC03, &ccm->CCGR1);
+	writel(0x0FFFC000, &ccm->CCGR2);
+	writel(0x3FF00000, &ccm->CCGR3);
+	writel(0x00FFF300, &ccm->CCGR4);
+	writel(0x0F0000C3, &ccm->CCGR5);
+	writel(0x000003FF, &ccm->CCGR6);
+}
+
+int mxxf1_pmic_setup(void)
+{
+	int ret;
+	i2c_set_bus_num(1);
+	ret = i2c_probe(CONFIG_POWER_PFUZE100_I2C_ADDR);
+	if (ret)
+	{
+		printf("%s: no pmic\n", __func__);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+
+static int mxxf1_pmic_set(pf100_regs reg, int mV)
+{
+	u8 values[2];
+
+	switch (reg) {
+
+	case SW1AB:
+		if (mV > 1425) {
+			printf("%s: SW1AB max is 1425 mV, reject %d mV\n", __func__, mV);
+			return -EINVAL;
+		}
+		values[0] = (mV - 300) / 25;
+		i2c_write(0x08, PFUZE100_SW1ABVOL, 1, values, 1);
+		break;
+
+	case SW1C:
+		if (mV > 1425) {
+			printf("%s: SW1AB max is 1425 mV, reject %d mV\n", __func__, mV);
+			return -EINVAL;
+		}
+		values[0] = (mV - 300) / 25;
+		i2c_write(0x08, PFUZE100_SW1CVOL, 1, values, 1);
+		break;
+
+	case SW3AB:
+		if (mV > 1500) {
+			printf("%s: SW3AB max is 1500 mV, reject %d mV\n", __func__, mV);
+			return -EINVAL;
+		}
+		values[0] = (mV - 400) / 25;
+		i2c_write(0x08, PFUZE100_SW3AVOL, 1, values, 1);
+		i2c_write(0x08, PFUZE100_SW3BVOL, 1, values, 1);
+		break;
+	}
+
+	return 0;
+}
+/*
+ * This section requires the differentiation between iMX6 Sabre boards, but
+ * for now, it will configure only for the mx6q variant.
+ */
+
+static struct mx6_ddr_sysinfo sysinfo = {
+	/* width of data bus:0=16,1=32,2=64 */
+	.dsize = 2,
+	/* config for full 4GB range so that get_mem_size() works */
+	.cs_density = 32, /* 32Gb per CS */
+	/* single chip select */
+	.ncs = 1,
+	.cs1_mirror = 0,
+	.rtt_wr = 1 /*DDR3_RTT_60_OHM*/,	/* RTT_Wr = RZQ/4 */
+	.rtt_nom = 1 /*DDR3_RTT_60_OHM*/,	/* RTT_Nom = RZQ/4 */
+	.walat = 1,	/* Write additional latency */
+	.ralat = 5,	/* Read additional latency */
+	.mif3_mode = 3,	/* Command prediction working mode */
+	.bi_on = 1,	/* Bank interleaving enabled */
+	.sde_to_rst = 0x10,	/* 14 cycles, 200us (JEDEC default) */
+	.rst_to_cke = 0x23,	/* 33 cycles, 500us (JEDEC default) */
+	.ddr_type = DDR_TYPE_DDR3,
+	.refsel = 1,	/* Refresh cycles at 32KHz */
+	.refr = 7,	/* 4 refresh commands per refresh cycle */
+};
+
+
+static void spl_dram_init(void)
+{
+	mx6dq_dram_iocfg(64, &mx6_ddr_ioregs, &mx6_grp_ioregs);
+#ifdef DYNAMIC_CALIB
+	mx6_dram_cfg(&sysinfo, &mx6_mmcd_calib, &mem_ddr);
+#else
+	mx6_dram_cfg(&sysinfo, &mx6_mmcd_calib_static, &mem_ddr);
+#endif
+}
+
+static void do_hang_error(void)
+{
+	for(;;) {
+		udelay(1000000);
+	}
+}
+
+void board_init_f(ulong dummy)
+{
+	int err, n;
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	ccgr_init();
+	gpr_init();
+#ifdef CONFIG_SPL_WATCHDOG_SUPPORT
+	hw_watchdog_init();
+#endif
+
+	/* iomux and setup of i2c */
+	board_early_init_f();
+
+	/* setup GP timer */
+	timer_init();
+
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+	err = mxxf1_pmic_setup();
+	if (err == 0) {
+		mxxf1_pmic_set(SW1AB, 1425);
+		mxxf1_pmic_set(SW1C, 1425);
+		mxxf1_pmic_set(SW3AB, 1350);
+		udelay(10000);
+	}
+
+	/* DDR initialization */
+
+
+	spl_dram_init();
+#ifdef DYNAMIC_CALIB
+	printf("Calibrating DDR3\n");
+	err = mmdc_do_write_level_calibration(&sysinfo);
+	if (err & 0x03) {
+		printf("DDR3 write level calibration error - hang\n");
+		do_hang_error();
+
+	}
+
+	err = mmdc_do_dqs_calibration(&sysinfo);
+	if (err) {
+		printf("DDR3 DQS calibration error - hang\n");
+		do_hang_error();
+	}
+#else
+	printf("Using static calibration values\n");
+#endif
+	mmdc_read_calibration(&sysinfo, &calib);
+	printf("Calibration results for PHY0\n");
+	printf("mpwldectrl0 = %08x\n", calib.p0_mpwldectrl0);
+	printf("mpwldectrl1 = %08x\n", calib.p0_mpwldectrl1);
+	printf("mpdgctrl0   = %08x\n", calib.p0_mpdgctrl0);
+	printf("mpdgctrl1   = %08x\n", calib.p0_mpdgctrl1);
+	printf("mprddlctl   = %08x\n", calib.p0_mprddlctl);
+	printf("mpwrdlctl   = %08x\n", calib.p0_mpwrdlctl);
+	printf("\nCalibration results for PHY1\n");
+	printf("mpwldectrl0 = %08x\n", calib.p1_mpwldectrl0);
+	printf("mpwldectrl1 = %08x\n", calib.p1_mpwldectrl1);
+	printf("mpdgctrl0   = %08x\n", calib.p1_mpdgctrl0);
+	printf("mpdgctrl1   = %08x\n", calib.p1_mpdgctrl1);
+	printf("mprddlctl   = %08x\n", calib.p1_mprddlctl);
+	printf("mpwrdlctl   = %08x\n", calib.p1_mpwrdlctl);
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	/* load/boot image from boot device */
+	board_init_r(NULL, 0);
+}
+
+#ifndef CONFIG_SPL_WATCHDOG_SUPPORT
+void reset_cpu(ulong addr)
+{
+}
+#endif
+#endif
diff --git a/board/datarespons/mxxf1/mxxf1_gpio.h b/board/datarespons/mxxf1/mxxf1_gpio.h
new file mode 100644
index 0000000000..b6686af8f8
--- /dev/null
+++ b/board/datarespons/mxxf1/mxxf1_gpio.h
@@ -0,0 +1,30 @@
+#ifndef __MXXF1_GPIO_H__
+#define __MXXF1_GPIO_H__
+
+#define GPIO_AUX_5V IMX_GPIO_NR(6, 10)
+#define GPIO_PCIE_RST_N IMX_GPIO_NR(7, 12)
+#define GPIO_EEPROM_WP	IMX_GPIO_NR(1, 5)
+#define GPIO_SPI_NOR_WP	IMX_GPIO_NR(6, 11)
+#define GPIO_LAN2_EE_WP	IMX_GPIO_NR(6, 14)
+#define GPIO_CAP_TOUCH_RST	IMX_GPIO_NR(6, 16)
+#define GPIO_CAP_TOUCH_PWR	IMX_GPIO_NR(1, 4)
+#define GPIO_LCD_EN	IMX_GPIO_NR(6, 15)
+#define GPIO_BL_EN	IMX_GPIO_NR(1, 2)
+#define GPIO_BL_PWM	IMX_GPIO_NR(1, 9)
+#define GPIO_FAN_EN IMX_GPIO_NR(1, 18)
+#define GPIO_BUZ_INT_EN IMX_GPIO_NR(1, 17)
+#define GPIO_BUZ_EXT_EN IMX_GPIO_NR(1, 19)
+
+#define GPIO_USB_H1_EN	IMX_GPIO_NR(1, 29)
+#define GPIO_USBP0_EN	IMX_GPIO_NR(3, 28)
+#define GPIO_USBP1_EN	IMX_GPIO_NR(2, 3)
+#define GPIO_USBP2_EN	IMX_GPIO_NR(2, 7)
+#define GPIO_USBP3_EN	IMX_GPIO_NR(6, 9)
+#define GPIO_LVDS_ROTATE IMX_GPIO_NR(7, 11)
+
+#define GPIO_DIMM_DN IMX_GPIO_NR(4, 6)
+#define GPIO_DIMM_UP IMX_GPIO_NR(4, 7)
+
+#define GPIO_TOUCH_IRQ IMX_GPIO_NR(6, 8)
+
+#endif
diff --git a/board/datarespons/mxxf1/param.c b/board/datarespons/mxxf1/param.c
new file mode 100644
index 0000000000..bfb3cf191a
--- /dev/null
+++ b/board/datarespons/mxxf1/param.c
@@ -0,0 +1,317 @@
+#include <common.h>
+#include <malloc.h>
+
+#include "param.h"
+#include <u-boot/crc.h>
+#include <errno.h>
+
+
+int param_init(struct param *e, const char *from, int size)
+{
+    e->size = size;
+    e->data = calloc(sizeof(char),size);
+    e->orig = calloc(sizeof(char),size);
+    e->max_params = size/4;
+    e->count = 0;
+    e->usage = 4;
+    e->param = calloc(sizeof(char*),e->max_params);
+
+    if (!e->data || !e->orig || !e->param)
+    {
+        printf( "%s: Internal error: Could not allocate memory. Aborting\n", __func__);
+        return 255;
+    }
+    memcpy(e->data, from, size);
+    memcpy(e->orig, from, size);
+    return 0;
+}
+
+int param_write(struct param *e, const char *where)
+{
+	memcpy((void*)where, e->data, e->size);
+	return 0;
+}
+
+int param_add(struct param *e, const char *param)
+{
+    if (e->count == e->max_params)
+    {
+        printf( "%s: Internal error: No free slot for parameter\n", __func__);
+        return -ENOMEM;
+    }
+    int len = strlen(param)+1;
+    if (len == 1)
+    {
+        printf( "%s: Internal error: Tried to add 0-length parameter\n", __func__);
+        return -EINVAL;
+    }
+    if (e->usage+len > e->size)
+    {
+        printf( "%s: Not enough free space to add parameter '%s'\n", __func__, param);
+        return -ENOMEM;
+    }
+
+    // Add the parameter to the list
+    //if (verbose)
+    //    printf("%s: Adding parameter '%s'\n", me, param);
+    e->param[e->count++] = strdup(param);
+    e->usage += len;
+    return 0;
+}
+
+
+
+int param_update(struct param *e, int index, const char *param)
+{
+    if (index<0 || index>=e->count)
+    {
+        printf( "%s: Internal error: Tried to update index out of range\n", __func__);
+        return 1;
+    }
+    int newl = strlen(param)+1;
+    int oldl = strlen(e->param[index])+1;
+    if (newl == 1)
+    {
+        printf( "%s: Internal error: Tried to update 0-length parameter\n",__func__);
+        return 1;
+    }
+
+    // Update the parameter
+    free(e->param[index]);
+    e->param[index] = strdup(param);
+    e->usage += newl-oldl;
+    return 0;
+}
+
+
+
+int param_find(struct param *e, const char *key)
+{
+    int i;
+    int len = strlen(key);
+    for(i=0; i<e->count; i++)
+    {
+        const char *param = e->param[i];
+
+        // Find the location of the '='
+        const char *sep = strchr(param,'=');
+
+        // Find the length of the key. If no '=' is found, use the full parameter.
+        int klen = (sep) ? sep-param : (signed)strlen(param);
+        if (klen != len)
+            continue;
+
+        // Compare the given key with the parameter key
+        if (!strncmp(key, param, klen))
+        {
+            return i;
+        }
+    }
+    printf( "%s: Did not find any key '%s'\n", __func__,key);
+    return -1;
+}
+
+
+
+int param_delete(struct param *e, int index)
+{
+    if (index<0 || index>=e->count)
+    {
+        printf( "%s: Internal error: Tried to delete index out of range\n", __func__);
+        return 1;
+    }
+    if (e->param[index] == NULL)
+        return 0;
+    int len = strlen(e->param[index])+1;
+
+    // Free the parameter
+    free(e->param[index]);
+    e->count--;
+    e->usage -= len;
+
+    // Shift all parameters up to fill the gap left by the removed param
+    while(index < e->count)
+    {
+        e->param[index] = e->param[index+1];
+        index++;
+    }
+    e->param[index] = NULL;
+    return 0;
+}
+
+
+
+int param_split(const char *param, char **key, char **data)
+{
+    char *s = strdup(param);
+    if ( NULL == s)
+    	return -ENOMEM;
+
+    char *sep = strchr(s,'=');
+    *key = s;
+    if (!sep)
+    {
+        *data = NULL;
+    }
+    else
+    {
+        *sep=0;
+        *data = sep+1;
+    }
+    return 0;
+}
+
+
+int param_set(struct param *e, const char *param)
+{
+    char *key, *data;
+    param_split(param, &key, &data);
+    int index = param_find(e,key);
+    free(key);
+    if (index >= 0)
+    {
+        return param_update(e,index,param);
+    }
+    return param_add(e,param);
+}
+
+
+
+int param_parse(struct param *e)
+{
+    //
+    // Verify CRC
+    //
+    uint8_t *p = (uint8_t*)(e->data);
+    uint32_t crc = (p[3]<<24) | (p[2]<<16) | (p[1]<<8) | (p[0]);
+    uint32_t checksum = crc32(0, &p[4], e->size-4);
+    if (crc != checksum)
+    {
+        printf("%s: Incorrect nvram checksum\n", __func__);
+        return -EINVAL;
+    }
+    else
+    {
+    	printf("%s: CRC checksum correct (%08X)\n", __func__, crc);
+    }
+
+
+    unsigned char *src = &(e->data[4]);
+    int remain = e->size-4;
+    while(remain > 0)
+    {
+        // Get parameter length (limit to end of buffer)
+        int len = strnlen((char*)src, remain);
+
+        // Done if no more strings or we see 0xFF
+        if (len == 0 || *src == 0xFF)
+            break;
+
+        // The last parameter does not have a trailing 0-terminator. Error?
+        if (len == remain)
+        {
+            printf( "%s: Invalid nvram data. Missing 0-termination on last parameter\n", __func__);
+            return -EINVAL;
+        }
+
+        // Add the parameter
+        printf( "%s:   Parsing '%s'\n", __func__, src);
+        int r = param_add(e, (char*)src);
+        if (r)
+            return r;
+
+        remain -= len+1;
+        src += len+1;
+    }
+
+    printf( "%s: Parsed %d parameters\n", __func__, e->count);
+
+    return 0;
+}
+
+
+int param_generate(struct param *e)
+{
+    unsigned char *dest = &(e->data[4]);
+    int remain = e->size-4;
+    int count=e->count;
+    int i = 0;
+
+    printf("%s: Going to generate %d parameters\n", __func__, count);
+
+    while(i < count)
+    {
+        char *param = e->param[i];
+        int len = strlen(param);
+
+        printf("%s:   Generating '%s'\n", __func__, param);
+
+        if (remain < len+1)
+        {
+            printf( "%s: No space left in nvram to write parameters\n", __func__);
+            return -1;
+        }
+
+        // Copy key and data to buffer and set '=' as the separator between them
+        strcpy((char*)dest, param);
+        dest += len+1;
+        remain -= len+1;
+        i++;
+    }
+
+    // Erase remainder of buffer
+    while(remain-- > 0)
+    {
+        *dest++=0xFF;
+    }
+
+
+    //
+    // Generate new CRC
+    //
+    uint8_t *p = (uint8_t*)(e->data);
+    uint32_t checksum = crc32(0, &p[4], e->size-4);
+    p[0] = checksum & 0xff;
+    p[1] = (checksum >> 8) & 0xff;
+    p[2] = (checksum >> 16) & 0xff;
+    p[3] = (checksum >> 24) & 0xff;
+
+    printf( "%s: Calculated new checksum (%08X)\n", __func__, checksum);
+
+    return 0;
+}
+
+int param_check_key(const char *key)
+{
+    int l = strlen(key);
+    if (l==0)
+        return 1;
+
+    int i;
+    for (i=0; i<l; i++)
+    {
+        char c = key[i];
+        if (c>='0' && c<='9')
+            continue;
+        if (c>='A' && c<='Z')
+            continue;
+        if (c=='_' || c=='-')
+            continue;
+        return 1;
+    }
+    return 0;
+}
+
+
+int param_check_data(const char *data)
+{
+    int l = strlen(data);
+    int i;
+    for (i=0; i<l; i++)
+    {
+        char c = data[i];
+        if (c<' ' || c>=0x7F)
+            return 1;
+    }
+    return 0;
+}
diff --git a/board/datarespons/mxxf1/param.h b/board/datarespons/mxxf1/param.h
new file mode 100644
index 0000000000..f33b5ceaf3
--- /dev/null
+++ b/board/datarespons/mxxf1/param.h
@@ -0,0 +1,40 @@
+#ifndef PARAM_H
+#define PARAM_H
+
+
+#define MAX_PARAMS 254
+
+struct param {
+
+    unsigned char *data;
+    unsigned char *orig;
+    int size;
+    int usage;
+
+    int count;
+    int max_params;
+    char **param;
+};
+
+
+int param_init(struct param *e, const char *from, int size);
+
+int param_add(struct param *e, const char *param);
+int param_update(struct param *e, int index, const char *param);
+int param_find(struct param *e, const char *key);
+
+int param_split(const char *param, char **key, char **data);
+
+int param_delete(struct param *e, int index);
+int param_set(struct param *e, const char *param);
+
+int param_parse(struct param *e);
+int param_generate(struct param *e);
+
+int param_write(struct param *e, const char *where);
+
+int param_check_key(const char *key);
+int param_check_data(const char *data);
+
+
+#endif  // PARAM_H
diff --git a/board/datarespons/mxxf1/spl_spi.cfg b/board/datarespons/mxxf1/spl_spi.cfg
new file mode 100644
index 0000000000..ad9f04dd5b
--- /dev/null
+++ b/board/datarespons/mxxf1/spl_spi.cfg
@@ -0,0 +1,10 @@
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	spi
diff --git a/configs/mxxf1_defconfig b/configs/mxxf1_defconfig
new file mode 100644
index 0000000000..5559b79645
--- /dev/null
+++ b/configs/mxxf1_defconfig
@@ -0,0 +1,62 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_SYS_TEXT_BASE=0x17800000
+CONFIG_TARGET_MXXF1=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/datarespons/mxxf1/mx6q_4x_mt41j128.cfg"
+CONFIG_BOOTDELAY=3
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_SATA=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="DR"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
+CONFIG_DEFAULT_FDT_FILE	"/boot/mxxf1.dtb"
+CONFIG_CMD_PART=y
+CONFIG_PARTITIONS=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_UUIDS=y
+CONFIG_PARTITION_TYPE_GUID=y
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_FLASH is not set
+CONFIG_MMC_HW_PARTITIONING=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_SATA=y
+CONFIG_BOARD_EARLY_INIT_F=y
+
+CONFIG_SYS_PROMPT="MXXF1 iMX6 # "
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_DISPLAY_BOARDINFO_LATE=y
+CONFIG_SPI=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_MXC_SPI=y
+CONFIG_SPI_BOOT=y
+CONFIG_CMD_SF=y
+CONFIG_FSL_ESDHC=y
+CONFIG_VIDEO=y
+CONFIG_CONSOLE_MUX
+CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP
+CONFIG_SYS_STDIO_DEREGISTER=y
diff --git a/configs/mxxf1_spl_defconfig b/configs/mxxf1_spl_defconfig
new file mode 100644
index 0000000000..771283d8a7
--- /dev/null
+++ b/configs/mxxf1_spl_defconfig
@@ -0,0 +1,79 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_SYS_TEXT_BASE=0x17800000
+CONFIG_TARGET_MXXF1=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/datarespons/mxxf1/spl_spi.cfg"
+CONFIG_BOOTDELAY=3
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_SATA=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="DR"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
+CONFIG_DEFAULT_FDT_FILE	"/boot/mxxf1.dtb"
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_SPL_SPI_LOAD=y
+CONFIG_IMX_WATCHDOG_ASSERT_WDOG_B=y
+CONFIG_HW_WATCHDOG=y
+CONFIG_WATCHDOG_TIMEOUT_MSECS=128000
+CONFIG_SPL=y
+CONFIG_SPL_EXT_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_OS_BOOT=n
+CONFIG_SPL_SPI_SUPPORT=y
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI_BOOT=y
+CONFIG_MX6_DDRCAL=y
+CONFIG_CMD_PART=y
+CONFIG_PARTITIONS=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_UUIDS=y
+CONFIG_PARTITION_TYPE_GUID=y
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_FLASH is not set
+CONFIG_MMC_HW_PARTITIONING=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_SATA=y
+CONFIG_SYS_PROMPT="MXXF1 iMX6 # "
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_DISPLAY_BOARDINFO_LATE=y
+CONFIG_SPI=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_MXC_SPI=y
+CONFIG_SPI_BOOT=y
+CONFIG_CMD_SF=y
+CONFIG_FSL_ESDHC=y
+CONFIG_VIDEO=y
+CONFIG_CONSOLE_MUX
+CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP
+CONFIG_SYS_STDIO_DEREGISTER=y
diff --git a/include/configs/mxxf1.h b/include/configs/mxxf1.h
new file mode 100644
index 0000000000..9208e3e4f4
--- /dev/null
+++ b/include/configs/mxxf1.h
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MXXF1_CONFIG_H
+#define __MXXF1_CONFIG_H
+
+
+#ifdef CONFIG_SPL
+#define CONFIG_SYS_SPI_U_BOOT_OFFS (256 * 1024)
+
+#include "imx6_spl.h"
+#undef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR 512
+#endif
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	0xffffffff
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk0p1"
+#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
+#define CONFIG_IMX_WATCHDOG
+#define CONFIG_IMX_THERMAL
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+#define CONFIG_SYS_GENERIC_BOARD
+
+#if defined(CONFIG_CMD_FUSE) || defined(CONFIG_IMX6_THERMAL)
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(40 * SZ_1M)
+
+#define CONFIG_MXC_UART
+
+/* MMC Configs */
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+
+
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_ETHPRIME			"FEC"
+#define CONFIG_FEC_MXC_PHYADDR		1
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+
+
+#ifdef CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_BUS		0
+#define CONFIG_SF_DEFAULT_CS		1
+#define CONFIG_SF_DEFAULT_SPEED		20000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#define CONFIG_CONS_INDEX              1
+#define CONFIG_BAUDRATE                        115200
+
+#define CONFIG_LOADADDR                0x12000000
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"zimage=/boot/zImage\0" \
+	"uimage=/boot/uImage\0" \
+	"panel=MXXF1-XGA\0" \
+	"fdt_addr=0x11000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=try\0" \
+	"hasusbkbd=no\0" \
+	"allow_usbkbd=yes\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"initrd_high=0xffffffff\0" \
+	"loglevel=3\0" \
+	"consoleblank=0\0" \
+	"stdin=serial,usbkbd\0" \
+	"showtty=console=ttymxc0,115200 console=tty1\0" \
+	"console=" CONSOLE_DEV ",115200\0" \
+	"setargs=setenv bootargs console=${console} root=${rootdev} rootwait ro rootfstype=ext4 fec_mac=${ethaddr} consoleblank=${consoleblank} loglevel=${loglevel} ${showtty}\0" \
+	"bootdev=0\0" \
+	"bootpart=1\0" \
+	"bootfrom=mmc\0" \
+	"rootdev=/dev/mmcblk0p1\0" \
+	"usb_root=/dev/sda1\0" \
+	"has_sata=0\0" \
+	"loadbootscript=if ext4load ${bootfrom} ${bootdev}:${bootpart} ${loadaddr} /boot/boot.txt; then env import -t ${loadaddr} ${filesize}; fi; \0" \
+	"setmmc=setenv bootfrom mmc; setenv bootdev 0; setenv bootpart 1; setenv rootdev /dev/mmcblk0p1; echo Setting boot to mmc; \0 " \
+	"setusb=setenv bootfrom usb; setenv bootdev 0; setenv bootpart 1; setenv rootdev ${usb_root}; echo Setting boot to usb; \0 " \
+	"setsata=setenv bootfrom sata; setenv bootdev 0; setenv bootpart 1; setenv rootdev /dev/sda1; echo Setting boot to sata; \0 " \
+	"loaduboot=ext4load ${bootfrom} ${bootdev}:${bootpart} ${loadaddr} /boot/u-boot.img; \0" \
+	"loadspl=ext4load ${bootfrom} ${bootdev}:${bootpart} ${loadaddr} /boot/SPL; \0" \
+	"flashspl=if run loadspl; then sf erase 0 10000; sf write ${loadaddr} 400 ${filesize}; fi; \0" \
+	"flashuboot=if run loaduboot; then sf erase 40000 90000; sf write ${loadaddr} 40000 ${filesize}; fi; \0" \
+	"loadimage=ext4load ${bootfrom} ${bootdev}:${bootpart} ${loadaddr} ${zimage}; \0" \
+	"loaduimage=ext4load ${bootfrom} ${bootdev}:${bootpart} ${loadaddr} ${uimage}; \0" \
+	"loadfdt=ext4load ${bootfrom} ${bootdev}:${bootpart} ${fdt_addr} ${fdt_file}; \0" \
+	"bootscript=run setargs; if run loadimage loadfdt; then bootz ${loadaddr} - ${fdt_addr}; else echo ERROR: Could not load image; fi; \0" \
+	"bootscript_legacy=run setargs; if run loaduimage ; then bootm ${loadaddr}; else echo ERROR: Could not load legacy image; fi; \0" \
+	"check_usb_boot=if usb storage; then run setusb loadfdt; fi;\0" \
+	"check_sata=if sata init; then setenv usb_root /dev/sdb1; setenv has_sata 1; fi;\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev 1; mmc rescan; run check_sata; " \
+	"if run check_usb_boot; then " \
+		"echo booting from USB ...;" \
+	"else " \
+		"if itest ${has_sata} == 1; then " \
+			"if run setsata loadfdt; then echo booting from SATA; else run setmmc; echo SATA failed, trying MMC ...; fi; " \
+		"else " \
+			"run setmmc; echo booting from MMC ...;" \
+		"fi; " \
+	"fi; " \
+	"run loadbootscript;" \
+	"run bootscript;" \
+	"run bootscript_legacy;"
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END         0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
+
+#define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
+
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/*  FLASH and environment organization */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_ENV_SIZE			(64 * 1024)
+#define CONFIG_ENV_SECT_SIZE 	(64 * 1024)
+#define CONFIG_ENV_SPI_BUS             CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS              CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE            CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ          CONFIG_SF_DEFAULT_SPEED
+#define CONFIG_ENV_OFFSET		(0xc0000)
+
+
+
+/* Framebuffer */
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#undef CONFIG_VIDEO_LOGO
+#undef CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_HDMI
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0	/* SDHC3 */
+#endif
+
+#define CONFIG_PWM_IMX
+#define CONFIG_IMX6_PWM_PER_CLK	66000000
+
+#define MXXF1_EEPROM_ADDR   0x50
+#define MXXF1_EEPROM_ADDR2  0x70
+#define MXXF1_EEPROM_SIZE 	2048
+
+
+#undef CONFIG_CMD_PCI
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(7, 12)
+#define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(3, 19)
+#endif
+
+/* SATA */
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+/* I2C Configs */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+
+/* USB Configs */
+#ifdef CONFIG_CMD_USB
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS		0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2 /* Enabled USB controller number */
+#define CONFIG_USBD_HS
+
+#if 0
+#define CONFIG_USB_KEYBOARD
+#define CONFIG_CONSOLE_MUX
+#define CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP
+#define CONFIG_SYS_STDIO_DEREGISTER
+#endif
+
+#endif
+
+#endif                         /* __MXXF1_CONFIG_H */
-- 
2.20.1

