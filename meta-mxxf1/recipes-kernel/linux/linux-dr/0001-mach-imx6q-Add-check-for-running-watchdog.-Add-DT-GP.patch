From b62de5c37cdb41ed099b4fde513959eccc994ec4 Mon Sep 17 00:00:00 2001
From: Hans Christian Lonstad <hcl@datarespons.no>
Date: Tue, 28 Apr 2020 12:46:58 +0200
Subject: [PATCH 1/3] mach-imx6q: Add check for running watchdog. Add DT GPIO
 mapper

The kernel can not know which wathcdog the bootloader started.
Check for running wachdog and pach DT runtime.
Add simple DT based GPIO pin instancer.
---
 arch/arm/mach-imx/mach-imx6q.c | 179 +++++++++++++++++++++++++++------
 1 file changed, 146 insertions(+), 33 deletions(-)

diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index 5bdb65dcd67f..3c8fd2c81aa3 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -6,6 +6,10 @@
 
 #include <linux/clk.h>
 #include <linux/irqchip.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/pci.h>
 #include <linux/phy.h>
@@ -26,15 +30,15 @@ static int ksz9021rn_phy_fixup(struct phy_device *phydev)
 	if (IS_BUILTIN(CONFIG_PHYLIB)) {
 		/* min rx data delay */
 		phy_write(phydev, MICREL_KSZ9021_EXTREG_CTRL,
-			0x8000 | MICREL_KSZ9021_RGMII_RX_DATA_PAD_SCEW);
+			  0x8000 | MICREL_KSZ9021_RGMII_RX_DATA_PAD_SCEW);
 		phy_write(phydev, MICREL_KSZ9021_EXTREG_DATA_WRITE, 0x0000);
 
 		/* max rx/tx clock delay, min rx/tx control delay */
 		phy_write(phydev, MICREL_KSZ9021_EXTREG_CTRL,
-			0x8000 | MICREL_KSZ9021_RGMII_CLK_CTRL_PAD_SCEW);
+			  0x8000 | MICREL_KSZ9021_RGMII_CLK_CTRL_PAD_SCEW);
 		phy_write(phydev, MICREL_KSZ9021_EXTREG_DATA_WRITE, 0xf0f0);
 		phy_write(phydev, MICREL_KSZ9021_EXTREG_CTRL,
-			MICREL_KSZ9021_RGMII_CLK_CTRL_PAD_SCEW);
+			  MICREL_KSZ9021_RGMII_CLK_CTRL_PAD_SCEW);
 	}
 
 	return 0;
@@ -80,7 +84,7 @@ static void ventana_pciesw_early_fixup(struct pci_dev *dev)
 	pci_write_config_dword(dev, 0x62c, dw);
 
 	pci_read_config_dword(dev, 0x644, &dw);
-	dw |= 0xfe;   // GPIO1-7 output high
+	dw |= 0xfe; // GPIO1-7 output high
 	pci_write_config_dword(dev, 0x644, dw);
 
 	msleep(100);
@@ -124,7 +128,7 @@ static int ar8031_phy_fixup(struct phy_device *dev)
 	return 0;
 }
 
-#define PHY_ID_AR8031	0x004dd074
+#define PHY_ID_AR8031 0x004dd074
 
 static int ar8035_phy_fixup(struct phy_device *dev)
 {
@@ -163,13 +167,13 @@ static void __init imx6q_enet_phy_init(void)
 {
 	if (IS_BUILTIN(CONFIG_PHYLIB)) {
 		phy_register_fixup_for_uid(PHY_ID_KSZ9021, MICREL_PHY_ID_MASK,
-				ksz9021rn_phy_fixup);
+					   ksz9021rn_phy_fixup);
 		phy_register_fixup_for_uid(PHY_ID_KSZ9031, MICREL_PHY_ID_MASK,
-				ksz9031rn_phy_fixup);
+					   ksz9031rn_phy_fixup);
 		phy_register_fixup_for_uid(PHY_ID_AR8031, 0xffffffef,
-				ar8031_phy_fixup);
+					   ar8031_phy_fixup);
 		phy_register_fixup_for_uid(PHY_ID_AR8035, 0xffffffef,
-				ar8035_phy_fixup);
+					   ar8035_phy_fixup);
 	}
 }
 
@@ -205,13 +209,12 @@ static void __init imx6q_1588_init(void)
 	 * (external OSC), and we need to clear the bit.
 	 */
 	clksel = clk_is_match(ptp_clk, enet_ref) ?
-				IMX6Q_GPR1_ENET_CLK_SEL_ANATOP :
-				IMX6Q_GPR1_ENET_CLK_SEL_PAD;
+			       IMX6Q_GPR1_ENET_CLK_SEL_ANATOP :
+			       IMX6Q_GPR1_ENET_CLK_SEL_PAD;
 	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
 	if (!IS_ERR(gpr))
 		regmap_update_bits(gpr, IOMUXC_GPR1,
-				IMX6Q_GPR1_ENET_CLK_SEL_MASK,
-				clksel);
+				   IMX6Q_GPR1_ENET_CLK_SEL_MASK, clksel);
 	else
 		pr_err("failed to find fsl,imx6q-iomuxc-gpr regmap\n");
 
@@ -240,9 +243,9 @@ static void __init imx6q_csi_mux_init(void)
 	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
 	if (!IS_ERR(gpr)) {
 		if (of_machine_is_compatible("fsl,imx6q-sabresd") ||
-			of_machine_is_compatible("fsl,imx6q-sabreauto") ||
-			of_machine_is_compatible("fsl,imx6qp-sabresd") ||
-			of_machine_is_compatible("fsl,imx6qp-sabreauto"))
+		    of_machine_is_compatible("fsl,imx6q-sabreauto") ||
+		    of_machine_is_compatible("fsl,imx6qp-sabresd") ||
+		    of_machine_is_compatible("fsl,imx6qp-sabreauto"))
 			regmap_update_bits(gpr, IOMUXC_GPR1, 1 << 19, 1 << 19);
 		else if (of_machine_is_compatible("fsl,imx6dl-sabresd") ||
 			 of_machine_is_compatible("fsl,imx6dl-sabreauto"))
@@ -259,8 +262,8 @@ static void __init imx6q_enet_clk_sel(void)
 
 	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
 	if (!IS_ERR(gpr))
-		regmap_update_bits(gpr, IOMUXC_GPR5,
-				   IMX6Q_GPR5_ENET_TX_CLK_SEL, IMX6Q_GPR5_ENET_TX_CLK_SEL);
+		regmap_update_bits(gpr, IOMUXC_GPR5, IMX6Q_GPR5_ENET_TX_CLK_SEL,
+				   IMX6Q_GPR5_ENET_TX_CLK_SEL);
 	else
 		pr_err("failed to find fsl,imx6q-iomux-gpr regmap\n");
 }
@@ -286,41 +289,149 @@ static void __init imx6q_axi_init(void)
 		 * AXI transactions.
 		 */
 		mask = IMX6Q_GPR4_VPU_WR_CACHE_SEL |
-			IMX6Q_GPR4_VPU_RD_CACHE_SEL |
-			IMX6Q_GPR4_VPU_P_WR_CACHE_VAL |
-			IMX6Q_GPR4_VPU_P_RD_CACHE_VAL_MASK |
-			IMX6Q_GPR4_IPU_WR_CACHE_CTL |
-			IMX6Q_GPR4_IPU_RD_CACHE_CTL;
+		       IMX6Q_GPR4_VPU_RD_CACHE_SEL |
+		       IMX6Q_GPR4_VPU_P_WR_CACHE_VAL |
+		       IMX6Q_GPR4_VPU_P_RD_CACHE_VAL_MASK |
+		       IMX6Q_GPR4_IPU_WR_CACHE_CTL |
+		       IMX6Q_GPR4_IPU_RD_CACHE_CTL;
 		regmap_update_bits(gpr, IOMUXC_GPR4, mask, mask);
 
 		/* Increase IPU read QoS priority */
 		regmap_update_bits(gpr, IOMUXC_GPR6,
-				IMX6Q_GPR6_IPU1_ID00_RD_QOS_MASK |
-				IMX6Q_GPR6_IPU1_ID01_RD_QOS_MASK,
-				(0xf << 16) | (0x7 << 20));
+				   IMX6Q_GPR6_IPU1_ID00_RD_QOS_MASK |
+					   IMX6Q_GPR6_IPU1_ID01_RD_QOS_MASK,
+				   (0xf << 16) | (0x7 << 20));
 		regmap_update_bits(gpr, IOMUXC_GPR7,
-				IMX6Q_GPR7_IPU2_ID00_RD_QOS_MASK |
-				IMX6Q_GPR7_IPU2_ID01_RD_QOS_MASK,
-				(0xf << 16) | (0x7 << 20));
+				   IMX6Q_GPR7_IPU2_ID00_RD_QOS_MASK |
+					   IMX6Q_GPR7_IPU2_ID01_RD_QOS_MASK,
+				   (0xf << 16) | (0x7 << 20));
 	} else {
 		pr_warn("failed to find fsl,imx6q-iomuxc-gpr regmap\n");
 	}
 }
+static void __init imx6q_add_gpio(void)
+{
+	struct device_node *user_gpios, *it;
+	int ret, gpio_nr;
+	u32 val;
+	unsigned long flags;
+	enum of_gpio_flags of_flags;
+
+	user_gpios = of_find_node_by_name(NULL, "user-gpios");
+	if (user_gpios) { /* Iterate nodes */
+		it = NULL;
+		while ((it = of_get_next_available_child(user_gpios, it))) {
+			gpio_nr = of_get_gpio_flags(it, 0, &of_flags);
+
+			if (!gpio_is_valid(gpio_nr)) {
+				pr_err("%s: Could not get gpio [%d]for %s\n",
+				       __func__, gpio_nr,
+				       of_node_full_name(it));
+				continue;
+			}
+			if (of_property_read_u32(it, "value", &val) == 0) {
+				flags = val ? GPIOF_OUT_INIT_HIGH :
+						    GPIOF_OUT_INIT_LOW;
+			} else
+				flags = GPIOF_DIR_IN;
+
+			flags |= GPIOF_EXPORT_DIR_CHANGEABLE;
+
+			ret = gpio_request_one(gpio_nr, flags, it->name);
+			if (ret < 0) {
+				pr_err("%s: Could not request gpio %d\n",
+				       __func__, gpio_nr);
+				continue;
+			}
+			pr_info("%s: Setting up gpio %s [%d], init=%d\n",
+				__func__, of_node_full_name(it), gpio_nr, val);
+		}
+		of_node_put(user_gpios);
+	}
+}
+
+static int __init imx6q_set_wdog_status(struct device_node *np, bool ok)
+{
+	struct property *status;
+	int avail = of_device_is_available(np);
+	pr_debug("%s: %s to %d\n", __func__, of_node_full_name(np), ok);
+	if ((avail && ok) || (!avail && !ok))
+		return 0;
+	status = kzalloc(sizeof(*status), GFP_KERNEL);
+	status->name = kstrdup("status", GFP_KERNEL);
+	status->value = kzalloc(20, GFP_KERNEL);
+	if (ok)
+		strcpy(status->value, "okay");
+	else
+		strcpy(status->value, "disabled");
+	status->length = strlen(status->value) + 1;
+
+	pr_info("%s: Setting status for %s to %s\n", __func__,
+		of_node_full_name(np), (char *)status->value);
+	of_update_property(np, status);
+	return 0;
+}
+
+static struct device_node *__init imx6q_wdog_started(void)
+{
+	static void __iomem *wdog_base;
+	struct device_node *np = NULL;
+	u32 wdog_wcr;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx21-wdt");
+	if (np) {
+		wdog_base = of_iomap(np, 0);
+		wdog_wcr = __raw_readw(wdog_base);
+		if (wdog_wcr & 0x04) {
+			return np;
+		} else {
+			np = of_find_compatible_node(np, NULL, "fsl,imx21-wdt");
+			if (np) {
+				wdog_base = of_iomap(np, 0);
+				wdog_wcr = __raw_readw(wdog_base);
+				if (wdog_wcr & 0x04) {
+					return np;
+				}
+			}
+		}
+	}
+	return NULL;
+}
 
 static void __init imx6q_init_machine(void)
 {
+	struct device_node *np, *np2;
+
 	if (cpu_is_imx6q() && imx_get_soc_revision() >= IMX_CHIP_REVISION_2_0)
 		imx_print_silicon_rev("i.MX6QP", IMX_CHIP_REVISION_1_0);
 	else
 		imx_print_silicon_rev(cpu_is_imx6dl() ? "i.MX6DL" : "i.MX6Q",
-				imx_get_soc_revision());
+				      imx_get_soc_revision());
+
+	imx6q_enet_phy_init();
 
+	np = imx6q_wdog_started();
+
+	if (np) {
+		pr_info("%s: Found bootloader activated watchdog %s - adjusting DT\n",
+			__func__, of_node_full_name(np));
+		imx6q_set_wdog_status(np, true);
+		np2 = of_find_compatible_node(NULL, NULL, "fsl,imx21-wdt");
+		if (np == np2)
+			np2 = of_find_compatible_node(np2, NULL,
+						      "fsl,imx21-wdt");
+		if (np2) {
+			imx6q_set_wdog_status(np2, false);
+			of_node_put(np2);
+		}
+		of_node_put(np);
+	}
 	of_platform_default_populate(NULL, NULL, NULL);
 
 	imx_anatop_init();
 	imx6q_enet_init();
 	imx6q_csi_mux_init();
-	cpu_is_imx6q() ?  imx6q_pm_init() : imx6dl_pm_init();
+	cpu_is_imx6q() ? imx6q_pm_init() : imx6dl_pm_init();
 	imx6q_axi_init();
 }
 
@@ -332,12 +443,14 @@ static void __init imx6q_init_late(void)
 	 *
 	 * It does work on imx6 Solo/DualLite starting from 1.1
 	 */
-	if ((cpu_is_imx6q() && imx_get_soc_revision() > IMX_CHIP_REVISION_1_1) ||
+	if ((cpu_is_imx6q() &&
+	     imx_get_soc_revision() > IMX_CHIP_REVISION_1_1) ||
 	    (cpu_is_imx6dl() && imx_get_soc_revision() > IMX_CHIP_REVISION_1_0))
 		imx6q_cpuidle_init();
 
 	if (IS_ENABLED(CONFIG_ARM_IMX6Q_CPUFREQ))
 		platform_device_register_simple("imx6q-cpufreq", -1, NULL, 0);
+	imx6q_add_gpio();
 }
 
 static void __init imx6q_map_io(void)
@@ -358,7 +471,7 @@ static void __init imx6q_init_irq(void)
 	imx6_pm_ccm_init("fsl,imx6q-ccm");
 }
 
-static const char * const imx6q_dt_compat[] __initconst = {
+static const char *const imx6q_dt_compat[] __initconst = {
 	"fsl,imx6dl",
 	"fsl,imx6q",
 	"fsl,imx6qp",
-- 
2.25.1

