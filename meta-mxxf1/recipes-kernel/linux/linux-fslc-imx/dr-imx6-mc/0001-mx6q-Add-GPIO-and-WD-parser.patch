From 3381099e9668777676dd4c3634113cff1190bc59 Mon Sep 17 00:00:00 2001
From: Hans Christian Lonstad <hcl@datarespons.no>
Date: Thu, 18 Nov 2021 20:58:16 +0100
Subject: [PATCH 1/4] mx6q: Add GPIO and WD parser

Set up non-driver GPIO pins from DT
Adapt watchdog number to bootloader (if needed)
---
 arch/arm/mach-imx/mach-imx6q.c | 112 +++++++++++++++++++++++++++++++++
 1 file changed, 112 insertions(+)

diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index 5bdb65dcd67f..dab92b27d80e 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -7,6 +7,9 @@
 #include <linux/clk.h>
 #include <linux/irqchip.h>
 #include <linux/of_platform.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
 #include <linux/pci.h>
 #include <linux/phy.h>
 #include <linux/regmap.h>
@@ -306,15 +309,123 @@ static void __init imx6q_axi_init(void)
 		pr_warn("failed to find fsl,imx6q-iomuxc-gpr regmap\n");
 	}
 }
+static void __init imx6q_add_gpio(void)
+{
+	struct device_node *user_gpios, *it;
+	int ret, gpio_nr;
+	u32 val;
+	unsigned long flags;
+	enum of_gpio_flags of_flags;
+
+	user_gpios = of_find_node_by_name(NULL, "user-gpios");
+	if (user_gpios) { /* Iterate nodes */
+		it = NULL;
+		while ((it = of_get_next_available_child(user_gpios, it))) {
+			gpio_nr = of_get_gpio_flags(it, 0, &of_flags);
+
+			if (!gpio_is_valid(gpio_nr)) {
+				pr_err("%s: Could not get gpio [%d]for %s\n",
+				       __func__, gpio_nr,
+				       of_node_full_name(it));
+				continue;
+			}
+			if (of_property_read_u32(it, "value", &val) == 0) {
+				flags = val ? GPIOF_OUT_INIT_HIGH :
+						    GPIOF_OUT_INIT_LOW;
+			} else
+				flags = GPIOF_DIR_IN;
+
+			flags |= GPIOF_EXPORT_DIR_CHANGEABLE;
+
+			ret = gpio_request_one(gpio_nr, flags, it->name);
+			if (ret < 0) {
+				pr_err("%s: Could not request gpio %d\n",
+				       __func__, gpio_nr);
+				continue;
+			}
+			pr_info("%s: Setting up gpio %s [%d], init=%d\n",
+				__func__, of_node_full_name(it), gpio_nr, val);
+		}
+		of_node_put(user_gpios);
+	}
+}
+
+static int __init imx6q_set_wdog_status(struct device_node *np, bool ok)
+{
+	struct property *status;
+	int avail = of_device_is_available(np);
+	pr_debug("%s: %s to %d\n", __func__, of_node_full_name(np), ok);
+	if ((avail && ok) || (!avail && !ok))
+		return 0;
+	status = kzalloc(sizeof(*status), GFP_KERNEL);
+	status->name = kstrdup("status", GFP_KERNEL);
+	status->value = kzalloc(20, GFP_KERNEL);
+	if (ok)
+		strcpy(status->value, "okay");
+	else
+		strcpy(status->value, "disabled");
+	status->length = strlen(status->value) + 1;
+
+	pr_info("%s: Setting status for %s to %s\n", __func__,
+		of_node_full_name(np), (char *)status->value);
+	of_update_property(np, status);
+	return 0;
+}
+
+static struct device_node *__init imx6q_wdog_started(void)
+{
+	static void __iomem *wdog_base;
+	struct device_node *np = NULL;
+	u32 wdog_wcr;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx21-wdt");
+	if (np) {
+		wdog_base = of_iomap(np, 0);
+		wdog_wcr = __raw_readw(wdog_base);
+		if (wdog_wcr & 0x04) {
+			return np;
+		} else {
+			np = of_find_compatible_node(np, NULL, "fsl,imx21-wdt");
+			if (np) {
+				wdog_base = of_iomap(np, 0);
+				wdog_wcr = __raw_readw(wdog_base);
+				if (wdog_wcr & 0x04) {
+					return np;
+				}
+			}
+		}
+	}
+	return NULL;
+}
 
 static void __init imx6q_init_machine(void)
 {
+	struct device_node *np, *np2;
+
 	if (cpu_is_imx6q() && imx_get_soc_revision() >= IMX_CHIP_REVISION_2_0)
 		imx_print_silicon_rev("i.MX6QP", IMX_CHIP_REVISION_1_0);
 	else
 		imx_print_silicon_rev(cpu_is_imx6dl() ? "i.MX6DL" : "i.MX6Q",
 				imx_get_soc_revision());
 
+	imx6q_enet_phy_init();
+
+	np = imx6q_wdog_started();
+
+	if (np) {
+		pr_info("%s: Found bootloader activated watchdog %s - adjusting DT\n",
+			__func__, of_node_full_name(np));
+		imx6q_set_wdog_status(np, true);
+		np2 = of_find_compatible_node(NULL, NULL, "fsl,imx21-wdt");
+		if (np == np2)
+			np2 = of_find_compatible_node(np2, NULL,
+						      "fsl,imx21-wdt");
+		if (np2) {
+			imx6q_set_wdog_status(np2, false);
+			of_node_put(np2);
+		}
+		of_node_put(np);
+	}
 	of_platform_default_populate(NULL, NULL, NULL);
 
 	imx_anatop_init();
@@ -338,6 +449,7 @@ static void __init imx6q_init_late(void)
 
 	if (IS_ENABLED(CONFIG_ARM_IMX6Q_CPUFREQ))
 		platform_device_register_simple("imx6q-cpufreq", -1, NULL, 0);
+	imx6q_add_gpio();
 }
 
 static void __init imx6q_map_io(void)
-- 
2.32.0

